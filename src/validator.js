// Generated by CoffeeScript 1.4.0
(function() {
  var Address, request, _;

  _ = require('underscore');

  request = require('request');

  /*
      Address object that provides useful methods. Create a new one by
        1. passing a map with these props: {street:'123 main st', city: 'boston', state: 'MA'|'massachussetts', country: 'US'|'United States'}
          None of the props are required, but chances are you wont have a valid address if you omit any of them (except for state)
        2. passing a string containing an address (the address class does not parse the string into parts)
        3. passing a result object from a google geocoding response. ie: geoResponse.results[0]
  
  
      The validator.validate callback will return to you these objects, except they will have all or some of the following properties:
          streetNumber: '100'
          street: 'North Main St'
          streetAbbr: 'N Main St'
          city: 'Boston'
          state: 'Massachussetts'
          stateAbbr: 'MA'
          country: 'United States'
          countryAbbr: 'US'
          postalCode: 02114
          location: {lat: 43.233332, lon: 23.2222243}
  
      Methods:
          toString(useCountryAbbr, useStateAbbr, useStreetAbbr) - returns a string representing the address. currently geared towards North American addresses
              useCountryAbbr = [optional] default: true - the resulting address string should use country abbr, not the full country name
              useStateAbbr   = [optional] default: true - the resulting address string should use state abbr, not the full state name
              useStreetAbbr  = [optional] default: false - the resulting address string should use street name abbr, not the full street name
              Note: the abbriviated values will only be used if they are available. The Address objects returned to you from the validate callback may have these available.
          equals(anotherAddress) - check if 2 addresses are probably* the same. IT DOES NOT CHECK STREET NAME/NUMBER
  */


  exports.Address = Address = (function() {

    function Address(address) {
      var city, country, countryAbbr, getComponent, location, postalCode, state, stateAbbr, street, streetAbbr, streetNum, x, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      if (_.isObject(address)) {
        this.isObject = true;
        if (address.address_components) {
          this.generated = true;
          location = {
            lat: (_ref = address.geometry) != null ? (_ref1 = _ref.location) != null ? _ref1.lat : void 0 : void 0,
            lon: (_ref2 = address.geometry) != null ? (_ref3 = _ref2.location) != null ? _ref3.lng : void 0 : void 0
          };
          getComponent = this.componentFinder(address.address_components);
          _ref4 = getComponent('street_number', false), x = _ref4[0], streetNum = _ref4[1];
          _ref5 = getComponent('route', false), streetAbbr = _ref5[0], street = _ref5[1];
          _ref6 = getComponent('locality'), x = _ref6[0], city = _ref6[1];
          _ref7 = getComponent('administrative_area_level_1'), stateAbbr = _ref7[0], state = _ref7[1];
          _ref8 = getComponent('country'), countryAbbr = _ref8[0], country = _ref8[1];
          _ref9 = getComponent('postal_code', false), postalCode = _ref9[0], x = _ref9[1];
          address = {
            streetNumber: streetNum,
            street: street,
            streetAbbr: streetAbbr,
            city: city,
            state: state,
            stateAbbr: stateAbbr,
            country: country,
            countryAbbr: countryAbbr,
            postalCode: postalCode,
            location: location
          };
        }
        _.each(address, function(val, key) {
          return _this[key] = val;
        });
      } else {
        this.isObject = false;
        this.addressStr = address;
      }
    }

    Address.prototype.componentFinder = function(components) {
      return function(type, type2) {
        var it;
        if (type2 == null) {
          type2 = "political";
        }
        it = _.find(components, function(c) {
          return c.types[0] === type && (!type2 || c.types[1] === type2);
        });
        return [it != null ? it.short_name : void 0, it != null ? it.long_name : void 0];
      };
    };

    Address.prototype.toString = function(useCountryAbbr, useStateAbbr, useStreetAbbr) {
      var arr, countryVal, prop, stateVal, str, streetVal, _i, _len, _ref;
      if (useCountryAbbr == null) {
        useCountryAbbr = true;
      }
      if (useStateAbbr == null) {
        useStateAbbr = true;
      }
      if (useStreetAbbr == null) {
        useStreetAbbr = false;
      }
      if (!this.isObject) {
        return this.addressStr;
      }
      arr = [];
      stateVal = useStateAbbr && this.generated ? 'stateAbbr' : 'state';
      countryVal = useCountryAbbr && this.generated ? 'countryAbbr' : 'country';
      streetVal = useStreetAbbr && this.generated ? 'streetAbbr' : 'street';
      _ref = [streetVal, 'city', stateVal, countryVal];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        if (this[prop]) {
          arr.push(this[prop]);
        }
      }
      str = arr.join(', ');
      if (this.streetNumber) {
        str = "" + this.streetNumber + " " + str;
      }
      return str;
    };

    Address.prototype.equals = function(address) {
      var compare, find, found, foundProps, haveProps, otherAddress, prop, props, value, _i, _len,
        _this = this;
      compare = function(prop) {
        if (_this[prop] && address[prop]) {
          if (_this[prop].toLowerCase() === address[prop].toLowerCase()) {
            return true;
          }
          if (address.generated && address[prop + 'Abbr']) {
            return _this[prop].toLowerCase() === address[prop + 'Abbr'].toLowerCase();
          } else if (_this.generated && _this[prop + 'Abbr']) {
            return _this[prop + 'Abbr'].toLowerCase() === address[prop].toLowerCase();
          } else {
            return false;
          }
        }
        return !_this[prop] && !address[prop];
      };
      if (this.isObject && address.isObject) {
        return compare('city') && compare('state') && compare('country');
      } else if (this.isObject && !address.isObject) {
        props = ['streetNumber', 'street', 'city', 'state', 'country', 'postalCode'];
        otherAddress = address.toString().toLowerCase();
        if (this.toString() === otherAddress) {
          return true;
        }
        foundProps = 0;
        haveProps = 0;
        find = function(val) {
          var oldlen;
          val = val.toLowerCase();
          oldlen = otherAddress.length;
          otherAddress = otherAddress.replace(new RegExp("\\b" + val + "\\b", "i"), "");
          if (oldlen !== otherAddress.length) {
            foundProps++;
            return true;
          }
          return false;
        };
        for (_i = 0, _len = props.length; _i < _len; _i++) {
          prop = props[_i];
          value = this[prop];
          if (value !== void 0) {
            found = find(this[prop]);
            if (!found && (prop === "state" || prop === "country" || prop === "street") && this[prop + "Abbr"] !== void 0) {
              found = find(this[prop + "Abbr"]);
            }
            if (!found && prop === "country" && value.toLowerCase() === "united states") {
              found = find("usa");
            }
            if (!found && prop === "street") {
              value = value.replace(/( street)/i, ' st');
              found = find(value);
              if (!found) {
                value = value.replace(/( road)/i, ' rd');
                find(value);
              }
            }
            if (!found && prop === "postalCode") {
              haveProps--;
            }
            haveProps++;
          }
        }
        otherAddress = otherAddress.replace(/[ ,]/g, '');
        return foundProps === haveProps && otherAddress.length === 0;
      } else {
        return this.toString().toLowerCase() === address.toString().toLowerCase();
      }
    };

    return Address;

  })();

  /*
      validate an input address.
  
      inputAddr: validator.Address object or map with 'street', 'city', 'state', 'country' keys, or string address
      cb: function(err, validAddresses, inexactMatches, geocodingResponse)
          err - something went wrong calling the google api
          validAddresses - list of Address objects. These are exact matches to your input, and will have proper spelling, caps etc. Its best that you use this instead of what you had
          inexactMatches - list of Address objects. Incomplete addresses or addresses that do not match your input address. useful for 'did you mean?' type UIs
          geocodingResponse - the json object that i got from google API
  */


  exports.validate = function(inputAddr, cb) {
    var inputAddress, opts, qs;
    inputAddress = inputAddr instanceof Address ? inputAddr : new Address(inputAddr);
    qs = {
      'sensor': false,
      'address': inputAddress.toString()
    };
    opts = {
      json: true,
      url: "http://maps.googleapis.com/maps/api/geocode/json",
      method: 'GET',
      qs: qs
    };
    return request(opts, function(err, response, body) {
      var inexactMatches, validAddresses;
      if (err) {
        return cb(err, null, null);
      }
      if (body.results.length === 0) {
        return cb(null, [], [], body);
      }
      if (response.statusCode !== 200) {
        return cb(new Error('Google geocode API returned status code of #{response.statusCode}', [], [], body));
      }
      validAddresses = [];
      inexactMatches = [];
      _.each(body.results, function(result) {
        var address;
        address = new Address(result);
        if (address.equals(inputAddress)) {
          return validAddresses.push(address);
        } else {
          return inexactMatches.push(address);
        }
      });
      return cb(null, validAddresses, inexactMatches, body);
    });
  };

}).call(this);
